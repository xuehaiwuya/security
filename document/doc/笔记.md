![2019-03-08_153304](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-08_153304.png)

springboot 的项目里面自带tomcat ，打包为jar包后，`java -jar demo.jar`也可以直接运行成功

maven 打包  package

### 服务异常处理 

错误页面自定义，可以放在如图所示文件下。但是只在web端生效，APP端不生效

![2019-03-14_083353](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_083353.png)



#### 自定义异常

```java
 @GetMapping("{id:\\d+}")
    @JsonView(User.UserDetailView.class)
    public User getInfo(@PathVariable String id){

        throw new UserNotExistException(id);

     /*  *//* System.out.println("进入getInfo服务");
        User user=new User();*//*
        user.setUsername("tom");
        return user;*/
    }
```

在此处抛出`UserNotExistException`异常

```java
public class UserNotExistException extends RuntimeException{

    private String id;

    public UserNotExistException(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}

```

可被接收处理

```java
@ControllerAdvice
public class ControllerExceptionHandler {

    public Map<String,Object> handlerUserNotExistException(UserNotExistException ex){
        Map<String,Object> result=new HashMap<>();
        result.put("id",ex.getId());
        result.put("message",ex.getMessage());
        return result;
    }
}
```



![2019-03-14_085142](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_085142.png)

![2019-03-14_085157](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_085157.png)

自定义异常显示

![2019-03-14_085327](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_085327.png)

### 使用Filter和Interceptor拦截REST服务

```java
//@Component
public class TimeFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("time filter init");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("time filter start");
        long start=new Date().getTime();
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("time filter 耗时:"+(new Date().getTime()-start));
        System.out.println("time filter finish");
    }

    @Override
    public void destroy() {
        System.out.println("time filter destroy");
    }
}

```

过滤器，当是自己写的时候，加个```@Component```就可以了。但是如果使用第三方框架没法修改源码时,如下所示。写一个配置类即可。

```java
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

    @Autowired
    private TimeInterceptor timeInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(timeInterceptor);
    }

    @Bean
    public FilterRegistrationBean timeFilter() {

        FilterRegistrationBean registrationBean = new FilterRegistrationBean();

        TimeFilter timeFilter = new TimeFilter();
        registrationBean.setFilter(timeFilter);

        List<String> urls = new ArrayList<>();
        urls.add("/*");
        registrationBean.setUrlPatterns(urls);

        return registrationBean;

    }

}

```

spring的拦截器如下所示，拦截器单纯的加```@Component```注解可不够，还要继承```WebMvcConfigurerAdapter```类，手动添加拦截器。自己写的过滤器却不需要，但拦截器比过滤器粒度更加细，得到更多的信息

```java
@Component
public class TimeInterceptor implements HandlerInterceptor {


    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
        System.out.println("preHandle");

        System.out.println(((HandlerMethod)handler).getBean().getClass().getName());
        System.out.println(((HandlerMethod)handler).getMethod().getName());

        httpServletRequest.setAttribute("startTime",new Date().getTime());
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle");
        Long start=(Long)httpServletRequest.getAttribute("startTime");
        System.out.println("time interceptor 耗时:"+(new Date().getTime()-start));
    }

    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) throws Exception {
        System.out.println("afterCompletion");
        Long start = (Long) httpServletRequest.getAttribute("startTime");
        System.out.println("time interceptor 耗时:"+ (new Date().getTime() - start));
        System.out.println("ex is "+ex);
    }
}
```

运行结果如下所示：

![2019-03-14_164310](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_164310.png)

```
time filter start
preHandle
com.imooc.web.controller.UserController
getInfo
进入getInfo服务
postHandle
time interceptor 耗时:35
afterCompletion
time interceptor 耗时:35
ex is null
time filter 耗时:57
time filter finish
```

### 使用切片拦截REST服务
![2019-03-14_165856](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_165856.png)

```java
@Aspect
@Component
public class TimeAspect {

    //执行 任何返回值  此类  任何方法 任何参数
    @Around("execution(* com.imooc.web.controller.UserController.*(..))")
    public Object handleControllerMethod(ProceedingJoinPoint proceedingJoinPoint)throws Throwable{
        System.out.println("time aspect start");

        Object[] args=proceedingJoinPoint.getArgs();
        for (Object arg:args){
            System.out.println("arg is "+arg);
        }

        long start=new Date().getTime();

        Object object=proceedingJoinPoint.proceed();

        System.out.println("time aspect 耗时:"+(new Date().getTime()-start));

        System.out.println("time aspect end");

        return object;
    }
}
```

```xml
 <!--Aspect 切面拦截-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
```

运行之后控制台

```
time filter start
preHandle
com.imooc.web.controller.UserController$$EnhancerBySpringCGLIB$$dbe78642
getInfo
time aspect start
arg is 1
进入getInfo服务
time aspect 耗时:3
time aspect end
postHandle
time interceptor 耗时:50
afterCompletion
time interceptor 耗时:50
ex is null
time filter 耗时:55
time filter finish
```

### 运行顺序总结

![2019-03-14_215327](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-14_215327.png)

### 文件上传与下载 

```java
@RestController
@RequestMapping("/file")
public class FileController {

    private String folder = "D:\\aacode\\java\\imooc\\imooc-security\\imooc-security-demo\\src\\main\\java\\com\\imooc\\web\\controller";

    @PostMapping
    public FileInfo upload(MultipartFile file)throws Exception{

        System.out.println("public FileInfo upload(MultipartFile file)方法");
        System.out.println(file.getName());
        System.out.println(file.getOriginalFilename());
        System.out.println(file.getSize());

        File localFile=new File(folder,new Date().getTime()+".txt");
        file.transferTo(localFile);

        return new FileInfo(localFile.getAbsolutePath());
    }

    @GetMapping("/{id}")
    public void download(@PathVariable String id, HttpServletRequest request, HttpServletResponse response)throws Exception{

        //写在小括号里面，IO流会自己关闭，省去累赘代码
        try (InputStream inputStream=new FileInputStream(new File(folder,id+".txt"));
             OutputStream outputStream=response.getOutputStream()){

            response.setContentType("application/x-download");
            response.addHeader("Content-Disposition","attachment;filename=test.txt");

            IOUtils.copy(inputStream,outputStream);
            outputStream.flush();
        }
    }

}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class FileInfo {

    private String path;
}
```

```java
@Test
public void whenUploadSuccess()throws Exception{
    String result=mockMvc.perform(fileUpload("/file")
        .file(new MockMultipartFile("file","test.txt","mutipart/form-data","hello upload".getBytes("UTF-8"))))
            .andExpect(status().isOk())
            .andReturn().getResponse().getContentAsString();
    System.out.println(result);
}
```

### 使用多线程提高REST服务性能

![2019-03-15_142428](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-15_142428.png)

![2019-03-15_143954](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-15_143954.png)

#### Runnable异步处理

首先关闭注解Timeaspect类   webconfig类的一个bean，一个addInterceptor，免得控制台信息太多

```java
package com.imooc.web.async;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.Callable;

/**
 * @Description
 * @auther 断弯刀
 * @create 2019-03-15 17:04
 */
@RestController
public class AsyncController {

    private Logger logger= LoggerFactory.getLogger(getClass());

    @RequestMapping("/order")
    public Callable<String> order()throws Exception{
        logger.info("主线程开始");

        Callable<String> result=new Callable<String>() {
            @Override
            public String call() throws Exception {
                logger.info("子线程开始");
                Thread.sleep(1000);
                logger.info("子线程返回");
                return "success";
            }
        };

        logger.info("主线程返回");
        return result;
    }
}
```

浏览器测试

![2019-03-15_171943](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-15_171943.png)

控制台信息

```java
2019-03-15 17:14:19.146  INFO 13944 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-03-15 17:14:19.146  INFO 13944 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2019-03-15 17:14:19.180  INFO 13944 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 34 ms
2019-03-15 17:14:19.218  INFO 13944 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程开始
2019-03-15 17:14:19.219  INFO 13944 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程返回
2019-03-15 17:14:19.226  INFO 13944 --- [      MvcAsync1] com.imooc.web.async.AsyncController      : 子线程开始
2019-03-15 17:14:20.228  INFO 13944 --- [      MvcAsync1] com.imooc.web.async.AsyncController      : 子线程返回
```

主线程开始后立马结束，副线程运行不影响主线程。意味着让主线程（即Tomcat的线程）去处理其它的HTTP请求。
意味着用这种方式写代码会对服务器的吞吐量有很大的提升。如上所示

#### DeferredResult异步处理

![2019-03-15_143721](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-15_143721.png)

```java
@Component
@Data
public class DeferredResultHolder {

    //key可以理解为每个订单号，每个订单号对应着订单的处理结果DeferredResult<String>
    private Map<String, DeferredResult<String>> map=new HashMap<>();

}
```

```java
@Component
@Slf4j
@Data
public class MockQueue {

    private String placeOrder;

    private String completeOrder;

    public void setPlaceOrder(String placeOrder)throws Exception{
        new Thread(() -> {
            log.info("接到下单请求: " + placeOrder);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            this.completeOrder=placeOrder;
            log.info("下单请求处理完毕: " + placeOrder);
        }).start();

    }

}
```

```java
@Component
@Slf4j
//ContextRefreshedEvent整个spring完全初始化完毕的事件
public class QueueListener implements ApplicationListener<ContextRefreshedEvent> {

    @Autowired
    private MockQueue mockQueue;

    @Autowired
    private DeferredResultHolder deferredResultHolder;

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {

        //无限的while循环，要是不单开线程的话，就会阻塞整个系统的启动
        new Thread(() -> {
            while (true){
                if (StringUtils.isNotBlank(mockQueue.getCompleteOrder())){
                    String orderNumber=mockQueue.getCompleteOrder();
                    log.info("返回订单处理结果:"+orderNumber);
                    //setResult()中为最终要返回的信息
                    deferredResultHolder.getMap().get(orderNumber).setResult("place order success");
                    mockQueue.setCompleteOrder(null);
                }else {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }

}
```

```java
@RestController
@Slf4j
public class AsyncController {

    @Autowired
    private MockQueue mockQueue;

    @Autowired
    private DeferredResultHolder deferredResultHolder;

    @RequestMapping("/order")
    public DeferredResult<String> order()throws Exception{
        log.info("主线程开始");

        //8倍的随机数（相当于订单号），放入消息队列中
        String orderNumber = RandomStringUtils.randomNumeric(8);
        mockQueue.setPlaceOrder(orderNumber);

        DeferredResult<String> result = new DeferredResult<>();
        deferredResultHolder.getMap().put(orderNumber, result);

        log.info("主线程结束");
        return result;

    }
}
```

浏览器输入和返回结果

![2019-03-16_112625](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-16_112625.png)

控制台信息

```java
2019-03-16 11:21:03.517  INFO 8200 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-03-16 11:21:03.517  INFO 8200 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2019-03-16 11:21:03.554  INFO 8200 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 36 ms
2019-03-16 11:21:03.590  INFO 8200 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程开始
2019-03-16 11:21:03.592  INFO 8200 --- [nio-8080-exec-1] com.imooc.web.async.AsyncController      : 主线程结束
2019-03-16 11:21:03.592  INFO 8200 --- [      Thread-45] com.imooc.web.async.MockQueue            : 接到下单请求: 09583296
2019-03-16 11:21:04.592  INFO 8200 --- [      Thread-45] com.imooc.web.async.MockQueue            : 下单请求处理完毕: 09583296
2019-03-16 11:21:04.689  INFO 8200 --- [      Thread-33] com.imooc.web.async.QueueListener        : 返回订单处理结果:09583296
```

3个线程，模拟了3个服务器

实际上有3个线程，一个是主线程接收HTTP请求，一个线程来处理真正的下单逻辑，另外一个线程把第二个线程的处理结果返回给前台。
线程1和线程3之间用DeferredResult来进行信息的交互。3个线程隔离，互相之间通过消息队列来通讯

### 使用Swagger自动生成文档

```xml
 <!--生成文档-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.7.0</version>
        </dependency>
        <!--生成可视化界面-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.7.0</version>
        </dependency>
```

类上加注解```@EnableSwagger2```

片段例子

```java
@EnableSwagger2
public class DemoApplication { 
    
 @ApiOperation(value = "用户查询服务")
	public List<User> query(UserQueryCondition condition,
			@PageableDefault(page = 2, size = 17, sort = "username,asc") Pageable pageable) {
        
 @ApiModelProperty(value = "用户年龄起始值")
	private int age;
	@ApiModelProperty(value = "用户年龄终止值")
	private int ageTo;

public User getInfo(@ApiParam("用户id") @PathVariable String id){
```

### 使用WireMock伪造REST服务

### SpringSecurity基本原理

![2019-03-16_161107](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-16_161107.png)

### 自定义用户认证逻辑

![2019-03-18_085640](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-18_091525.png)

application.properties    默认安全认证即打开

```properties
# security.basic.enabled = true
```

浏览器进入

![2019-03-19_155529](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_155529.png)

修改配置，改为表单登录

```java
@Configuration
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin()
            .and()
            .authorizeRequests()
            .anyRequest()    //任何请求
            .authenticated();   //都需要认证
    }
}

```

```java
@Slf4j
@Component
public class MyUserDetailsService implements UserDetailsService {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        log.info("用户名："+username);
        //指定用户授权登录信息
        //密码加密，使用的是盐值加密
        String password = passwordEncoder.encode("123456");
        log.info("数据库中密码是："+password);
        //User类是Spring内置的一个类，实现了UserDetails接口，而这个接口是UserDetailSerice的子接口
        return new User(username, password, true, true, true, true
                , AuthorityUtils.commaSeparatedStringToAuthorityList("admin"));
    }

}
```

![2019-03-19_163456](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_163456.png)

控制台信息

```
2019-03-19 16:32:00.172  INFO 10532 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-03-19 16:32:00.172  INFO 10532 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2019-03-19 16:32:00.209  INFO 10532 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 37 ms
2019-03-19 16:32:13.766  INFO 10532 --- [nio-8080-exec-4] c.i.s.browser.MyUserDetailsService       : 用户名：zjx
2019-03-19 16:32:13.882  INFO 10532 --- [nio-8080-exec-4] c.i.s.browser.MyUserDetailsService       : 数据库中密码是：$e0801$GYPznAhqFHKSas4OpdjmGZ1w1PTT6oQXlTnpjQEc9+gcWb6LdeB69iGFzZF+8Dftt0tGNro1AOG63E61LSN4Yw==$zHyK7F/nnUnhp2mtDJIeNun2lyqU13LylTFw7YNDhBw=
```

### 个性化用户认证流程

![2019-03-19_143943](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_143943.png)

#### 自定义登录界面

​	注意loginPage和antMatchers放行登录页面，不然会一直重定向。还需注意的是登录页面内部先不要填写引用的超链接，不然还是会被拦截，会被跳转到404页面

```java
@Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //认证
            .loginPage("/imooc-signIn.html")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
            .and()
                .authorizeRequests()   //授权
                 //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/imooc-signIn.html").permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();

    }
```
目录结构

![2019-03-19_172900](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_172900.png)

![2019-03-18_092533](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-18_092533.png)

系统配置封装

浏览器安全相关配置项、验证码相关配置项、等等

![2019-03-18_093712](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-18_093712.png)

将登录路径改为 /authentication/require，再写controller控制处理

```java
@Configuration
@Slf4j
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        //这里如果是自己编写的加密 则调用自己的类 方法有编码和解码验证方法
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
      
        http.formLogin() //认证
            .loginPage("/authentication/require")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
            .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require", securityProperties.getBrowser().getLoginPage()).permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();

    }
}
```

controller控制处理，如果是 .html 后缀来的，重定向到登录页面去。否则返回json信息

```java
@RestController
@Slf4j
public class BrowserSecurityController {

    private RequestCache requestCache = new HttpSessionRequestCache();

    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 当需要身份验证时跳转到这里
     * @param request
     * @param response
     * @return
     * @throws Exception
     */
    @RequestMapping("/authentication/require")
    @ResponseStatus(code = HttpStatus.UNAUTHORIZED)   //返回401状态码
    public SimpleResponse requireAuthentication(HttpServletRequest request, HttpServletResponse response)throws Exception {

        //保存的之前的请求(引发跳转的请求)拿出来
        SavedRequest savedRequest = requestCache.getRequest(request, response);
        if (savedRequest != null) {
            //引发跳转的url
            String targetUrl=savedRequest.getRedirectUrl();
            log.info("引发跳转的请求是:"+targetUrl);
            if (StringUtils.endsWithIgnoreCase(targetUrl, "html")) {
                redirectStrategy.sendRedirect(request, response, securityProperties.getBrowser().getLoginPage());
                log.info("BrowserSecurityController==>securityProperties.getBrowser().getLoginPage()=="+securityProperties.getBrowser().getLoginPage());
            }
        }
        return new SimpleResponse("访问的服务需要身份认证,请引导用户到登录页");
    }
}
```

```java
@Data
@AllArgsConstructor
public class SimpleResponse {

    private Object content;

}
```

系统配置不管是在浏览器还是在APP模块都会被用到，所以写到core模块中。

SecurityProperties

```java
//意思是这个类会读取配置文件中所有以imooc.security开头的配置项
//其中browser的配置项会读取到BrowserProperties的对象中去
@ConfigurationProperties(prefix = "imooc.security")
@Component
@Data
public class SecurityProperties {

    private BrowserProperties browser = new BrowserProperties();
}
```
EnableConfigurationProperties让ConfigurationProperties标注的注解生效

```java
@Configuration
@EnableConfigurationProperties(SecurityProperties.class)
//让BrowserProperties生效
public class SecurityCoreConfig {
}
```

图中对应关系

![2019-03-19_220530](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-19_220530.png)

```java
@Data
public class BrowserProperties {

    //设定默认值如果没有指定loginPage则访问该页面
    private String loginPage="/imooc-signIn.html";

}
```

#### 自定义登陆成功、失败处理

成功处理器

```java
@Component("imoocAuthenticationSuccessHandler")
@Slf4j
public class ImoocAuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {

    //启动的时候springmvc会注册一个mapper
    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private SecurityProperties securityProperties;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws ServletException, IOException {
       log.info("登录成功");

        if (LoginResponseType.JSON.equals(securityProperties.getBrowser().getLoginType())) {
            response.setContentType("application/json;charset=utf-8");
            response.getWriter().write(objectMapper.writeValueAsString(authentication));
        } else {
            super.onAuthenticationSuccess(request, response, authentication);
        }
    }
}

```
失败处理器

```java
@Component("imoocAuthenticationFailureHandler")
@Slf4j
public class ImoocAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private SecurityProperties securityProperties;

    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
       log.info("登录失败");

        if (LoginResponseType.JSON.equals(securityProperties.getBrowser().getLoginType())) {
            response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
            response.setContentType("application/json;charset=utf-8");
            response.getWriter().write(objectMapper.writeValueAsString(new SimpleResponse(exception.getMessage())));
        } else {
            super.onAuthenticationFailure(request, response, exception);
        }
    }
}
```

```java
public enum LoginResponseType {

    /**
     * 跳转
     */
    REDIRECT,

    /**
     * 返回json
     */
    JSON
}
```
注意变量名一定要和application.properties中的名字一一对应，否则找不到不生效

```java
@Data
public class BrowserProperties {

    //设定默认值如果没有指定loginPage则访问该页面
    private String loginPage = "/imooc-signIn.html";

    private LoginResponseType loginType = LoginResponseType.JSON;  //默认返回json

}
```

```pro
imooc.security.browser.loginType = REDIRECT
```

最后注入使其生效

```java
@Configuration
@Slf4j
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    //让系统使用我们自定义 而不是系统默认的配置
    @Autowired
    private ImoocAuthenticationSuccessHandler imoocAuthenticationSuccessHandler;

    @Autowired
    private ImoocAuthenticationFailureHandler imoocAuthenticationFailureHandler;

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        //这里如果是自己编写的加密 则调用自己的类 方法有编码和解码验证方法
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //认证
            .loginPage("/authentication/require")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
                .successHandler(imoocAuthenticationSuccessHandler)  //成功后 使用我们自己的处理器处理
                .failureHandler(imoocAuthenticationFailureHandler)  //设置失败处理器
            .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require", securityProperties.getBrowser().getLoginPage()).permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();

    }
}

```

测试如果输入index.html路径，会先被拦截让登陆。若用户名密码正确而且返回类型为REDIRECT时，会自动跳转到index.html页面

### 图片验证码

![2019-03-20_115554](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_115554.png)

![2019-03-20_115722](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_115722.png)

![2019-03-20_122943](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_122943.png)

验证码实体类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ImageCode {

    private BufferedImage image;

    private String code;  //随机数存到session中

    private LocalDateTime expireTime;  //有效时间

    public ImageCode (BufferedImage image,String code,
                      int expireIn) {
        this.image=image;
        this.code=code;
        this.expireTime=LocalDateTime.now().plusSeconds(expireIn);
    }

    public boolean isExpried(){
        //如果 过期时间 在 当前日期 之前，则验证码过期
        return LocalDateTime.now().isAfter(expireTime);
    }
}

```

验证码Controller，此时即可显示验证码，但需要写过滤器验证

```java
@RestController
public class ValidateCodeController {

    public static final String SESSION_KEY = "SESSION_KEY_IMAGE_CODE";

    private SessionStrategy sessionStrategy=new HttpSessionSessionStrategy();

    @GetMapping("/code/image")
    public void createCode(HttpServletRequest request, HttpServletResponse response)throws Exception {
        ImageCode imageCode = createImageCode(request);
        //code放到sesison 第二步
        sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, imageCode);
        //将图片写到响应的接口中 第三步
        ImageIO.write(imageCode.getImage(), "JPEG", response.getOutputStream());
    }

    private ImageCode createImageCode(HttpServletRequest request) {
        //第一步 生成随机验证码 可以去网上搜
        int width=67;//宽和高
        int height=23;
        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_BGR);

        Graphics g = image.getGraphics();

        Random random = new Random();

        g.setColor(getRandColor(200,250));
        g.fillRect(0, 0, width, height);
        g.setFont(new Font("Times New Roman",Font.ITALIC,20));
        g.setColor(getRandColor(160,200));
        for(int i=0;i<155;i++) {
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl =random.nextInt(12);
            int yl =random.nextInt(12);
            g.drawLine(x, y, x+xl, y+yl);
        }

        String sRand = "";
        for (int i = 0; i < 4; i++) {//数字验证码长度
            String rand = String.valueOf(random.nextInt(10));
            sRand +=rand;
            g.setColor(new Color(20 + random.nextInt(110),
                    20 + random.nextInt(110),20 + random.nextInt(110)));
            g.drawString(rand, 13*i+6, 16);
        }

        g.dispose();

        return new ImageCode(image,sRand,60);//有效期60秒
    }

    /**
     * 生成随机背景条纹
     */
    private Color getRandColor(int fc,int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r,g,b);
    }
}
```

过滤器，自动注入AuthenticationFailureHandler，实际为`com.imooc.security.browser.authentication.ImoocAuthenticationFailureHandler`类，自定义了异常类`ValidateCodeException`，有任何逻辑不对就抛出异常，再让`ImoocAuthenticationFailureHandler`处理。否则进行下一个过滤器

```java
@Data
@Slf4j
public class ValidateCodeFilter extends OncePerRequestFilter {

    @Autowired
    private AuthenticationFailureHandler authenticationFailureHandler;

    private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //主干逻辑
        //必须是个请求路径并且必须是post请求
        if (StringUtils.equals("/authentication/form", request.getRequestURI()) && StringUtils.equalsIgnoreCase(request.getMethod(), "post")) {
            try {
                //校验逻辑
                validate(new ServletWebRequest(request));
            }catch (ValidateCodeException e){
                log.info("ValidateCodeFilter==>doFilterInternal==>authenticationFailureHandler.getClass().getName()== "+authenticationFailureHandler.getClass().getName());
                authenticationFailureHandler.onAuthenticationFailure(request, response, e);
                return;
            }
        }

        filterChain.doFilter(request, response);
    }

    //校验逻辑
    private void validate(ServletWebRequest request) throws ServletRequestBindingException {

        ImageCode codeInSession = (ImageCode)sessionStrategy.getAttribute(request,
                ValidateCodeController.SESSION_KEY);

        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), "imageCode");

        if (StringUtils.isBlank(codeInRequest)) {
            throw new ValidateCodeException("验证码的值不能为空,the code must be not null");
        }
        if (codeInSession == null) {
            throw new ValidateCodeException("验证码不存在");
        }
        if (codeInSession.isExpried()) {
            sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
            throw new ValidateCodeException("验证码已过期");
        }
        if (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) {
            throw new ValidateCodeException("验证码不匹配");
        }

        sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
    }
}

```

```java
public class ValidateCodeException extends AuthenticationException {


    /**
     *
     */
    private static final long serialVersionUID = -7285211528095468156L;

    public ValidateCodeException(String msg) {
        super(msg);
    }
}
```

最后配置信息要添加上

```java
@Configuration
@Slf4j
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    //让系统使用我们自定义 而不是系统默认的配置
    @Autowired
    private ImoocAuthenticationSuccessHandler imoocAuthenticationSuccessHandler;

    @Autowired
    private ImoocAuthenticationFailureHandler imoocAuthenticationFailureHandler;

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        //这里如果是自己编写的加密 则调用自己的类 方法有编码和解码验证方法
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {

        ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter();
        validateCodeFilter.setAuthenticationFailureHandler(imoocAuthenticationFailureHandler);

        //在UsernamePasswordAuthenticationFilter 过滤器前 加一个过滤器 来搞验证码
        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                .formLogin() //认证
            .loginPage("/authentication/require")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
                .successHandler(imoocAuthenticationSuccessHandler)  //成功后 使用我们自己的处理器处理
                .failureHandler(imoocAuthenticationFailureHandler)  //设置失败处理器
            .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require"
                        , securityProperties.getBrowser().getLoginPage()
                        , "/code/image").permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();

    }
}
```

###  图片验证码重构

![2019-03-20_165036](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_165036.png)

![2019-03-20_165120](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-20_165120.png)

验证码实体类

```java
@Data
public class ImageCodeProperties {

    private int width = 67;
    private int height = 23;
    private int length = 4;    //验证码长度
    private int expireIn = 60;   //失效时间

    private String url;
}
```

```java
@Data
public class ValidateCodeProperties {

    private ImageCodeProperties image = new ImageCodeProperties();

}
```

```java
//意思是这个类会读取配置文件中所有以imooc.security开头的配置项
//其中browser的配置项会读取到BrowserProperties的对象中去
@ConfigurationProperties(prefix = "imooc.security")
@Data
public class SecurityProperties {

    private BrowserProperties browser = new BrowserProperties();

    private ValidateCodeProperties code = new ValidateCodeProperties();
}
```

这是在配置拦截的路径接口

```java
/**
 * 校验验证码的过滤器
 * @Description
 * @auther 断弯刀
 * @create 2019-03-20 14:35
 */
@Data
@Slf4j
//InitializingBean在其他参数都组装完毕以后，初始化urls的值
public class ValidateCodeFilter extends OncePerRequestFilter implements InitializingBean {

    /**
     * 验证码校验失败处理器
     */
    @Autowired
    private AuthenticationFailureHandler authenticationFailureHandler;

    private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();

    /**
     * 存放所有需要校验验证码的url
     */
    private Set<String> urls = new HashSet<>();

    /**
     * 系统配置信息
     */
    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 验证请求url与配置的url是否匹配的工具类
     */
    private AntPathMatcher antPathMatcher = new AntPathMatcher();

    /**
     * 初始化要拦截的url配置信息
     * @throws ServletException
     */
    @Override
    public void afterPropertiesSet() throws ServletException {
        String[] configUrls = StringUtils.splitByWholeSeparator(securityProperties.getCode().getImage().getUrl(), ",");
        for (String url : configUrls) {
            urls.add(url);
        }
        urls.add("/authentication/form");
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        boolean action = false;
        log.info("urls的长度是:" + urls.size() + "它们是：" + urls.toString());
        log.info("requestUri是:" + request.getRequestURI());
        for (String url : urls) {
            if (antPathMatcher.match(url, request.getRequestURI())) {
                action = true;
            }
        }
        if (action) {
            try {
                //校验逻辑
                validate(new ServletWebRequest(request));
            }catch (ValidateCodeException e){
                authenticationFailureHandler.onAuthenticationFailure(request, response, e);
                return;
            }
        }
        filterChain.doFilter(request, response);
    }

    //校验逻辑
    private void validate(ServletWebRequest request) throws ServletRequestBindingException {

        ImageCode codeInSession = (ImageCode)sessionStrategy.getAttribute(request,
                ValidateCodeController.SESSION_KEY);

        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), "imageCode");

        if (StringUtils.isBlank(codeInRequest)) {
            throw new ValidateCodeException("验证码的值不能为空,the code must be not null");
        }
        if (codeInSession == null) {
            throw new ValidateCodeException("验证码不存在");
        }
        if (codeInSession.isExpried()) {
            sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
            throw new ValidateCodeException("验证码已过期");
        }
        if (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) {
            throw new ValidateCodeException("验证码不匹配");
        }

        sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
    }
}

```
配置进去

```java
@Configuration
@Slf4j
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    //让系统使用我们自定义 而不是系统默认的配置
    @Autowired
    private ImoocAuthenticationSuccessHandler imoocAuthenticationSuccessHandler;

    @Autowired
    private ImoocAuthenticationFailureHandler imoocAuthenticationFailureHandler;

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        //这里如果是自己编写的加密 则调用自己的类 方法有编码和解码验证方法
        return new SCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {

        ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter();
        validateCodeFilter.setAuthenticationFailureHandler(imoocAuthenticationFailureHandler);
        validateCodeFilter.setSecurityProperties(securityProperties);
        validateCodeFilter.afterPropertiesSet();

        //在UsernamePasswordAuthenticationFilter 过滤器前 加一个过滤器 来搞验证码
        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                .formLogin() //认证
            .loginPage("/authentication/require")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
                .successHandler(imoocAuthenticationSuccessHandler)  //成功后 使用我们自己的处理器处理
                .failureHandler(imoocAuthenticationFailureHandler)  //设置失败处理器
            .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require"
                        , securityProperties.getBrowser().getLoginPage()
                        , "/code/image").permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();
    }
}
```

验证码信息封装类，自己封装了个`isExpried()`方法

```java
@Data
@AllArgsConstructor
public class ValidateCode implements Serializable {

    /**
     *
     */
    private static final long serialVersionUID = 1588203828504660915L;

    private String code;   //随机数存到session中

    private LocalDateTime expireTime;   //有效时间

    public ValidateCode(String code, int expireIn){
        this.code = code;
        this.expireTime = LocalDateTime.now().plusSeconds(expireIn);
    }

    public boolean isExpried() {
        return LocalDateTime.now().isAfter(expireTime);
    }
}
```

图片验证码具体类继承`ValidateCode`，其实就是多了一个`BufferedImage`对象

```java
@Data
public class ImageCode extends ValidateCode {

    private BufferedImage image;

    public ImageCode(BufferedImage image, String code, int expireIn){
        super(code, expireIn);
        this.image = image;
    }

    public ImageCode(BufferedImage image, String code, LocalDateTime expireTime){
        super(code, expireTime);
        this.image = image;
    }
}
```

校验码生成器

```java
public interface ValidateCodeGenerator {

    /**
     * 生成校验码
     * @param request
     * @return
     */
    ValidateCode generate(ServletWebRequest request);
}
```

默认的图片验证码生成器

```java
@Data
public class ImageCodeGenerator implements ValidateCodeGenerator {

    /**
     * 系统配置
     */
    @Autowired
    private SecurityProperties securityProperties;

    @Override
    public ImageCode generate(ServletWebRequest request) {
        //生成随机验证码
        int width = ServletRequestUtils.getIntParameter(request.getRequest(), "width", securityProperties.getCode().getImage().getWidth());//宽和高
        int height = ServletRequestUtils.getIntParameter(request.getRequest(), "height", securityProperties.getCode().getImage().getHeight());
        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_BGR);

        Graphics g = image.getGraphics();

        Random random = new Random();

        g.setColor(getRandColor(200,250));
        g.fillRect(0, 0, width, height);
        g.setFont(new Font("Times New Roman",Font.ITALIC,20));
        g.setColor(getRandColor(160,200));
        for(int i=0;i<155;i++) {
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl =random.nextInt(12);
            int yl =random.nextInt(12);
            g.drawLine(x, y, x+xl, y+yl);
        }

        String sRand = "";
        for (int i = 0; i < securityProperties.getCode().getImage().getLength(); i++) {   //数字验证码长度
            String rand = String.valueOf(random.nextInt(10));
            sRand +=rand;
            g.setColor(new Color(20 + random.nextInt(110),
                    20 + random.nextInt(110),20 + random.nextInt(110)));
            g.drawString(rand, 13*i+6, 16);
        }

        g.dispose();

        return new ImageCode(image,sRand,60);//有效期60秒
    }

    /**
     * 生成随机背景条纹
     */
    private Color getRandColor(int fc,int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r,g,b);
    }
}
```

验证码相关的扩展点配置

```java
@Configuration
public class ValidateCodeBeanConfig {

    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 在触发 ValidateCodeGenerator 之前会检测有没有imageCodeGenerator这个bean。
     * 如果能找到，则不会用ValidateCodeGenerator，而是用找到的imageCodeGenerator
     * @return
     */
    @Bean
    @ConditionalOnMissingBean(name = "imageCodeGenerator")
    public ValidateCodeGenerator imageCodeGenerator() {
        ImageCodeGenerator codeGenerator = new ImageCodeGenerator();
        codeGenerator.setSecurityProperties(securityProperties);
        return codeGenerator;
    }
}
```

生成校验码的请求处理器

```java
@RestController
public class ValidateCodeController {

    public static final String SESSION_KEY = "SESSION_KEY_IMAGE_CODE";

    private SessionStrategy sessionStrategy=new HttpSessionSessionStrategy();

    @Autowired
    private ValidateCodeGenerator imageCodeGenerator;

    /**
     * 创建验证码
     * @param request
     * @param response
     * @throws Exception
     */
    @GetMapping("/code/image")
    public void createCode(HttpServletRequest request, HttpServletResponse response)throws Exception {
        ImageCode imageCode = (ImageCode)imageCodeGenerator.generate(new ServletWebRequest(request));
        //code放到sesison 第二步
        sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, imageCode);
        //将图片写到响应的接口中 第三步
        ImageIO.write(imageCode.getImage(), "JPEG", response.getOutputStream());
    }

}
```

测试DemoImageCodeGenerator

```java
//@Component("imageCodeGenerator")
public class DemoImageCodeGenerator implements ValidateCodeGenerator {

    @Override
    public ValidateCode generate(ServletWebRequest request) {
        System.out.println("更高级的图形验证码生成代码");
        return null;
    }
}
```

<table><tr><td bgcolor=orange>验证测试</td></tr></table>

#### 验证码基本参数可配置

浏览器进入index.html，被拦截，如图所示

![2019-03-21_075417](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_075417.png)

验证码位数为6，说明demo模块中的application.properties中的配置生效。demo模块覆盖了core模块`ImageCodeProperties`默认的值

```properties
imooc.security.code.image.length = 6
imooc.security.code.image.width = 100
imooc.security.code.image.url = /user,/user/*
```

验证码图片长度明显太长：    browser模块中imooc-signIn.html部分

```html
<tr>
				<td>图形验证码:</td>
				<td>
					<input type="text" name="imageCode">
					<img src="/code/image?width=200">
				</td>
			</tr>
```

说明`width=200 `覆盖了demo模块中的`imooc.security.code.image.width = 100`的值

#### 验证码拦截的接口可配置

​	`ValidateCodeFilter`中的`urls`存放所有需要校验验证码的url。` urls.add("/authentication/form");`是登录表单的提交路径，当然需要添加。

```java
String[] configUrls = StringUtils.splitByWholeSeparator(securityProperties.getCode().getImage().getUrl(), ",");
        for (String url : configUrls) {
            urls.add(url);
        }
```

以上代码是获取手动配置的需要拦截的路径

验证：登录页面什么都不填写直接点击登录会被拦截，说明`urls.add("/authentication/form");`生效，如图所示

![2019-03-21_082145](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_082145.png)

http://localhost:8080/user 路径会被拦截，说明自己配置的路径被拦截生效。如图所示

![2019-03-21_082226](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_082226.png)

#### 验证码的生成逻辑可配置

直接测试即可将`DemoImageCodeGenerator`类上添加注解`@Component("imageCodeGenerator")`

进入index.html，让其生成验证码。结果图片生成失败，如图所示

![2019-03-21_083904](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_083904.png)

控制台信息，报空指针异常，因为返回为null

![2019-03-21_083816](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-21_083816.png)

### 添加记住我功能

![2019-03-22_123051](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-22_123051.png)

![2019-03-22_124241](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-22_124241.png)

![2019-03-22_124337](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-22_124337.png)

```java
@Data
public class BrowserProperties {

    //设定默认值如果没有指定loginPage则访问该页面
    private String loginPage = "/imooc-signIn.html";

    private LoginResponseType loginType = LoginResponseType.JSON;  //默认返回json

    private int rememberMeSeconds = 3600;

}
```

```java
@Configuration
@Slf4j
public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private SecurityProperties securityProperties;

    //让系统使用我们自定义 而不是系统默认的配置
    @Autowired
    private ImoocAuthenticationSuccessHandler imoocAuthenticationSuccessHandler;

    @Autowired
    private ImoocAuthenticationFailureHandler imoocAuthenticationFailureHandler;

    //记住我后的登录页面
    @Autowired
    private UserDetailsService userDetailsService;

    //注入密码加密的类
    @Bean
    public PasswordEncoder passwordEncoder() {
        //这里如果是自己编写的加密 则调用自己的类 方法有编码和解码验证方法
        return new SCryptPasswordEncoder();
    }

    @Autowired
    private DataSource dataSource;

    //记住我的功能
    @Bean
    public PersistentTokenRepository getPersistentTokenRespsitory() {
        JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl = new JdbcTokenRepositoryImpl();
        // 配置数据源
        jdbcTokenRepositoryImpl.setDataSource(dataSource);
        //启动时创建一张表，这个参数到第二次启动时必须注释掉，因为已经创建了一张表
        //jdbcTokenRepositoryImpl.setCreateTableOnStartup(true);
        return jdbcTokenRepositoryImpl;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {

        ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter();
        validateCodeFilter.setAuthenticationFailureHandler(imoocAuthenticationFailureHandler);
        validateCodeFilter.setSecurityProperties(securityProperties);
        validateCodeFilter.afterPropertiesSet();

        //在UsernamePasswordAuthenticationFilter 过滤器前 加一个过滤器 来搞验证码
        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                .formLogin() //认证
            .loginPage("/authentication/require")  //设置登录页面
                .loginProcessingUrl("/authentication/form") //遇到该请求则进行user password认证
                .successHandler(imoocAuthenticationSuccessHandler)  //成功后 使用我们自己的处理器处理
                .failureHandler(imoocAuthenticationFailureHandler)  //设置失败处理器
             .and()
                .rememberMe()
                    .tokenRepository(getPersistentTokenRespsitory())
                    .tokenValiditySeconds(securityProperties.getBrowser().getRememberMeSeconds())         // 配置Cookie过期时间
                    .userDetailsService(userDetailsService)
            .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require"
                        , securityProperties.getBrowser().getLoginPage()
                        , "/code/image").permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
            .and()
                .csrf().disable();
    }
}
```

当用户发起认证请求，会通过`UsernamePasswordAuthenticationFilter`，在认证成功之后，可以调用`SpringSecurity`提供的`RememberMeService`，它会生成一个Token并将它写入浏览器的Cookie中，同时这个它里面有一个`TokenRepositoryTokenRepository`会将Token放入数据库中。 
当下次浏览器再请求的时候，会经过`RememberMeAuthenticationFiler`，在这个filter里面会读取Cookie中的Token，然后去数据库中查找是否有相应的Token，然后再通过`UserDetailsService`获取用户的信息。

第二次启动不注释会报的错：

```java
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'getPersistentTokenRespsitory' defined in class path resource [com/imooc/security/browser/BrowserSecurityConfig.class]: Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Initialization of DAO failed; nested exception is org.springframework.jdbc.BadSqlGrammarException: StatementCallback; bad SQL grammar [create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null)]; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table 'persistent_logins' already exists
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1628) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867) ~[spring-context-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543) ~[spring-context-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122) ~[spring-boot-1.5.6.RELEASE.jar:1.5.6.RELEASE]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) [spring-boot-1.5.6.RELEASE.jar:1.5.6.RELEASE]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) [spring-boot-1.5.6.RELEASE.jar:1.5.6.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) [spring-boot-1.5.6.RELEASE.jar:1.5.6.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) [spring-boot-1.5.6.RELEASE.jar:1.5.6.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) [spring-boot-1.5.6.RELEASE.jar:1.5.6.RELEASE]
	at com.imooc.DemoApplication.main(DemoApplication.java:15) [classes/:na]
Caused by: org.springframework.beans.factory.BeanInitializationException: Initialization of DAO failed; nested exception is org.springframework.jdbc.BadSqlGrammarException: StatementCallback; bad SQL grammar [create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null)]; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table 'persistent_logins' already exists
	at org.springframework.dao.support.DaoSupport.afterPropertiesSet(DaoSupport.java:51) ~[spring-tx-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1687) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1624) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	... 16 common frames omitted
Caused by: org.springframework.jdbc.BadSqlGrammarException: StatementCallback; bad SQL grammar [create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null)]; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table 'persistent_logins' already exists
	at org.springframework.jdbc.support.SQLExceptionSubclassTranslator.doTranslate(SQLExceptionSubclassTranslator.java:91) ~[spring-jdbc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:73) ~[spring-jdbc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) ~[spring-jdbc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:419) ~[spring-jdbc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:443) ~[spring-jdbc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl.initDao(JdbcTokenRepositoryImpl.java:62) ~[spring-security-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]
	at org.springframework.dao.support.DaoSupport.afterPropertiesSet(DaoSupport.java:48) ~[spring-tx-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	... 18 common frames omitted
Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table 'persistent_logins' already exists
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.8.0_112]
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:1.8.0_112]
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.8.0_112]
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[na:1.8.0_112]
	at com.mysql.jdbc.Util.handleNewInstance(Util.java:425) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.Util.getInstance(Util.java:408) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:943) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3973) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3909) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2527) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2680) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2490) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2448) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.StatementImpl.executeInternal(StatementImpl.java:845) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at com.mysql.jdbc.StatementImpl.execute(StatementImpl.java:745) ~[mysql-connector-java-5.1.43.jar:5.1.43]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_112]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_112]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_112]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_112]
	at org.apache.tomcat.jdbc.pool.StatementFacade$StatementProxy.invoke(StatementFacade.java:114) ~[tomcat-jdbc-8.5.16.jar:na]
	at com.sun.proxy.$Proxy109.execute(Unknown Source) ~[na:na]
	at org.springframework.jdbc.core.JdbcTemplate$1ExecuteStatementCallback.doInStatement(JdbcTemplate.java:435) ~[spring-jdbc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:408) ~[spring-jdbc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	... 21 common frames omitted


Process finished with exit code 1

```

登陆成功后数据库表中的数据

![2019-03-22_151246](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-22_151246.png)

经测试登陆成功后重启服务器，再次进入路径/user，可直接查询，不用登录。验证成功

### 短信验证码接口开发

![2019-03-22_154149](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-22_154149.png)

`ValidateCodeController`：前后跳转控制器
`ValidateCodeProcessor`: 验证码的具体逻辑接口
`AbstractValidateCodeProcessor`: 抽象类实现验证码的具体逻辑
`ImageCodeProcessor`: 图片验证码具体逻辑实现
`SmsCodeProcessor`: 短信验证码具体逻辑实现
`ValidateCodeGenerator`: 验证码生成接口
`SmsCodeGenerator`: 短信验证码生成类
`ImageCodeGenerator`:图片验证码生成类



短信验证码属性实体

```java
@Data
public class SmsCodeProperties {

    /**
     * 验证码长度
     */
    private int length = 6;
    /**
     * 过期时间
     */
    private int expireIn = 60;
    /**
     * 要拦截的url，多个url用逗号隔开，ant pattern
     */
    private String url;

}
```


验证码配置

```java
@Data
public class ValidateCodeProperties {

    /**
     * 图片验证码配置
     */
    private ImageCodeProperties image = new ImageCodeProperties();

    /**
     * 短信验证码配置
     */
    private SmsCodeProperties sms = new SmsCodeProperties();

}
```


短信验证码生成器

```java
@Component("smsCodeGenerator")
public class SmsCodeGenerator implements ValidateCodeGenerator {

    @Autowired
    private SecurityProperties securityProperties;

    @Override
    public ValidateCode generate(ServletWebRequest request) {
        String code = RandomStringUtils.randomNumeric(securityProperties.getCode().getSms().getLength());
        return new ValidateCode(code, securityProperties.getCode().getSms().getExpireIn());
    }

}
```

校验码处理器，封装不同校验码的处理逻辑

```java
public interface ValidateCodeProcessor {

    /**
     * 验证码放入session时的前缀
     */
    String SESSION_KEY_PREFIX = "SESSION_KEY_FOR_CODE_";

    /**
     * 创建校验码
     * @param request
     * @throws Exception
     */
    void create(ServletWebRequest request) throws Exception;
}
```

抽象的验证码处理器`AbstractValidateCodeProcessor`

```java
public abstract class AbstractValidateCodeProcessor<C extends ValidateCode> implements ValidateCodeProcessor {

    /**
     * 操作session的工具类
     */
    private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();

    /**
     * 收集系统中所有的 {@link ValidateCodeGenerator} 接口的实现。
     */
    @Autowired
    private Map<String, ValidateCodeGenerator> validateCodeGenerators;

    @Override
    public void create(ServletWebRequest request) throws Exception {
        C validateCode = generate(request);
        save(request, validateCode);
        send(request, validateCode);
    }

    /**
     * 生成校验码
     * @param request
     * @return
     */
    private C generate(ServletWebRequest request) {
        String type = getProcessorType(request);
        ValidateCodeGenerator validateCodeGenerator = validateCodeGenerators.get(type + "CodeGenerator");
        return (C) validateCodeGenerator.generate(request);
    }

    /**
     * 保存校验码
     * @param request
     * @param validateCode
     */
    private void save(ServletWebRequest request, C validateCode) {
        sessionStrategy.setAttribute(request, SESSION_KEY_PREFIX + getProcessorType(request).toUpperCase(), validateCode);
    }

    /**
     * 发送校验码，由子类实现
     * @param request
     * @param validateCode
     * @throws Exception
     */
    protected abstract void send(ServletWebRequest request,C validateCode)throws Exception;

    /**
     * 根据请求的url获取校验码的类型
     * @param request
     * @return
     */
    private String getProcessorType(ServletWebRequest request) {
        return StringUtils.substringAfter(request.getRequest().getRequestURI(), "/code/");
    }
}
```

图片验证码处理器

```java
@Component("imageCodeProcessor")
public class ImageCodeProcessor extends AbstractValidateCodeProcessor<ImageCode> {

    /**
     * 发送图形验证码，将其写到响应中
     */
    @Override
    protected void send(ServletWebRequest request, ImageCode imageCode) throws Exception {
        ImageIO.write(imageCode.getImage(), "JPEG", request.getResponse().getOutputStream());
    }
}
```

短信验证码处理器

```java
@Component("smsCodeProcessor")
public class SmsCodeProcessor extends AbstractValidateCodeProcessor<ValidateCode> {

    /**
     * 短信验证码发送器
     */
    @Autowired
    private SmsCodeSender smsCodeSender;

    @Override
    protected void send(ServletWebRequest request, ValidateCode validateCode) throws Exception {
        String mobile = ServletRequestUtils.getRequiredStringParameter(request.getRequest(), "mobile");
        smsCodeSender.send(mobile, validateCode.getCode());
    }
}
```

生成校验码的请求处理器

```java
@RestController
public class ValidateCodeController {

    @Autowired
    private Map<String, ValidateCodeProcessor> validateCodeProcessors;

    /**
     * 创建验证码，根据验证码类型不同，调用不同的 {@link ValidateCodeProcessor}接口实现
     * @param request
     * @param response
     * @param type
     * @throws Exception
     */
    @GetMapping("/code/{type}")
    public void createCode(HttpServletRequest request, HttpServletResponse response, @PathVariable String type)throws Exception {
        validateCodeProcessors.get(type + "CodeProcessor").create(new ServletWebRequest(request, response));
    }

}
```
短信验证码发送器接口

```java
public interface SmsCodeSender {

    void send(String mobile, String code);
}
```

默认的短信验证码发送器

```java
public class DefaultSmsCodeSender implements SmsCodeSender{

    @Override
    public void send(String mobile, String code) {
        System.out.println("向手机"+mobile+"发送短信验证码"+code);
    }
}
```

验证码相关的扩展点配置

```java
@Configuration
public class ValidateCodeBeanConfig {

    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 在触发 ValidateCodeGenerator 之前会检测有没有imageCodeGenerator这个bean。
     * 如果能找到，则不会用ValidateCodeGenerator，而是用找到的imageCodeGenerator
     * @return
     */
    @Bean
    @ConditionalOnMissingBean(name = "imageCodeGenerator")
    public ValidateCodeGenerator imageCodeGenerator() {
        ImageCodeGenerator codeGenerator = new ImageCodeGenerator();
        codeGenerator.setSecurityProperties(securityProperties);
        return codeGenerator;
    }

    /**
     * 短信验证码发送器
     * ConditionalOnMissingBean 两种参数配置方式
     * @return
     */
    @Bean
    @ConditionalOnMissingBean(SmsCodeSender.class)
    public SmsCodeSender smsCodeSender() {
        return new DefaultSmsCodeSender();
    }

}
```

BrowserSecurityConfig

```java
   .and()
                .authorizeRequests()   //授权
                //当访问这个路径的时候不需要身份认证 除了它其他的是需要身份认证
                .antMatchers("/authentication/require"
                        , securityProperties.getBrowser().getLoginPage()
                        , "/code/image", "/code/sms").permitAll()
                .anyRequest()    //任何请求
                .authenticated()   //都需要认证
```

校验验证码的过滤器`ValidateCodeFilter` 先改一点

```java
//校验逻辑
    private void validate(ServletWebRequest request) throws ServletRequestBindingException {

        ImageCode codeInSession = (ImageCode) sessionStrategy.getAttribute(request,
                ValidateCodeProcessor.SESSION_KEY_PREFIX + "IMAGE");

        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), "imageCode");

        if (StringUtils.isBlank(codeInRequest)) {
            throw new ValidateCodeException("验证码的值不能为空,the code must be not null");
        }
        if (codeInSession == null) {
            throw new ValidateCodeException("验证码不存在");
        }
        if (codeInSession.isExpried()) {
            sessionStrategy.removeAttribute(request, ValidateCodeProcessor.SESSION_KEY_PREFIX + "IMAGE");
            throw new ValidateCodeException("验证码已过期");
        }
        if (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) {
            throw new ValidateCodeException("验证码不匹配");
        }

        sessionStrategy.removeAttribute(request, ValidateCodeProcessor.SESSION_KEY_PREFIX + "IMAGE");
    }
```

图形验证码的可配置点在于生成的多样性，短信验证码的可配置点在于发送的多样性

<table><tr><td bgcolor=orange>先产生验证码，再保存和发送验证码，分离接口、便于扩展<br><br>继承可以消除冗余，eg：倘若两个实体类有很多相同的属性，那么可以用继承</td></tr></table>

测试验证，点击发送验证码，发送成功

显示  向手机13012345678发送短信验证码124382

![2019-03-23_180942](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-23_180942.png)

### 短信登录开发、配置及重构

![2019-03-23_085125](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-23_085125.png)

![2019-03-23_204646](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-23_204646.png)

此章节牵扯类太多，细节有诸多错误。最终代码须看GitHub

短信登录验证地位同等于账号密码登录，所以可以模仿`UsernamePasswordAuthenticationToken`类

短信登录验证信息封装类

```java
public class SmsCodeAuthenticationToken extends AbstractAuthenticationToken {

    private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;

    private final Object principal;

    /**
     * This constructor can be safely used by any code that wishes to create a
     * <code>UsernamePasswordAuthenticationToken</code>, as the {@link #isAuthenticated()}
     * will return <code>false</code>.
     *
     */
    public SmsCodeAuthenticationToken(String mobile) {
        super(null);
        this.principal = mobile;
        setAuthenticated(false);
    }

    /**
     * This constructor should only be used by <code>AuthenticationManager</code> or
     * <code>AuthenticationProvider</code> implementations that are satisfied with
     * producing a trusted (i.e. {@link #isAuthenticated()} = <code>true</code>)
     * authentication token.
     *
     * @param principal
     * @param authorities
     */
    public SmsCodeAuthenticationToken(Object principal, Collection<? extends GrantedAuthority> authorities) {
        super(authorities);
        this.principal = principal;
        super.setAuthenticated(true);
    }

    @Override
    public Object getCredentials() {
        return null;
    }

    @Override
    public Object getPrincipal() {
        return this.principal;
    }

    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {
        if (isAuthenticated) {
            throw new IllegalArgumentException(
                    "Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead");
        }

        super.setAuthenticated(false);
    }

    @Override
    public void eraseCredentials() {
        super.eraseCredentials();
    }
}
```

短信登录过滤器`SmsCodeAuthenticationFilter`参照`UsernamePasswordAuthenticationFilter`

```java
public class SmsCodeAuthenticationFilter extends AbstractAuthenticationProcessingFilter {

    // ~ Static fields/initializers
    // =====================================================================================

    private String mobileParameter = SecurityConstants.DEFAULT_PARAMETER_NAME_MOBILE;
    private boolean postOnly = true;

    // ~ Constructors
    // ===================================================================================================
    //处理的短信登录的请求是什么
    public SmsCodeAuthenticationFilter() {
        super(new AntPathRequestMatcher(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_MOBILE, "POST"));
    }

    // ~ Methods
    // ========================================================================================================

    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
            throws AuthenticationException {
        if (postOnly && !request.getMethod().equals("POST")) {
            throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());
        }

        String mobile = obtainMobile(request);

        if (mobile == null) {
            mobile = "";
        }

        mobile = mobile.trim();

        // 将请求的信息设置在Token中
        SmsCodeAuthenticationToken authRequest = new SmsCodeAuthenticationToken(mobile);

        // Allow subclasses to set the "details" property
        setDetails(request, authRequest);
        //拿着Token调用AuthenticationManager
        return this.getAuthenticationManager().authenticate(authRequest);
    }

    /**
     * 获取请求参数中的手机号
     */
    protected String obtainMobile(HttpServletRequest request) {
        return request.getParameter(mobileParameter);
    }

    /**
     * 将请求的信息设置在Token中
     * Provided so that subclasses may configure what is put into the
     * authentication request's details property.
     *
     * @param request
     *            that an authentication request is being created for
     * @param authRequest
     *            the authentication request object that should have its details
     *            set
     */
    protected void setDetails(HttpServletRequest request, SmsCodeAuthenticationToken authRequest) {
        authRequest.setDetails(authenticationDetailsSource.buildDetails(request));
    }

    /**
     * Sets the parameter name which will be used to obtain the username from
     * the login request.
     *
     * @param usernameParameter
     *            the parameter name. Defaults to "username".
     */
    public void setMobileParameter(String usernameParameter) {
        Assert.hasText(usernameParameter, "Username parameter must not be empty or null");
        this.mobileParameter = usernameParameter;
    }


    /**
     * Defines whether only HTTP POST requests will be allowed by this filter.
     * If set to true, and an authentication request is received which is not a
     * POST request, an exception will be raised immediately and authentication
     * will not be attempted. The <tt>unsuccessfulAuthentication()</tt> method
     * will be called as if handling a failed authentication.
     * <p>
     * Defaults to <tt>true</tt> but may be overridden by subclasses.
     */
    public void setPostOnly(boolean postOnly) {
        this.postOnly = postOnly;
    }

    public final String getMobileParameter() {
        return mobileParameter;
    }

}
```

常量接口

```java
public interface SecurityConstants {

    /**
     * 默认的处理验证码的url前缀
     */
    public static final String DEFAULT_VALIDATE_CODE_URL_PREFIX = "/code";
    /**
     * 当请求需要身份认证时，默认跳转的url
     *
     * @see SecurityController
     */
    public static final String DEFAULT_UNAUTHENTICATION_URL = "/authentication/require";
    /**
     * 默认的用户名密码登录请求处理url
     */
    public static final String DEFAULT_LOGIN_PROCESSING_URL_FORM = "/authentication/form";
    /**
     * 默认的手机验证码登录请求处理url
     */
    public static final String DEFAULT_LOGIN_PROCESSING_URL_MOBILE = "/authentication/mobile";
    /**
     * 默认登录页面
     *
     * @see SecurityController
     */
    public static final String DEFAULT_LOGIN_PAGE_URL = "/imooc-signIn.html";
    /**
     * 验证图片验证码时，http请求中默认的携带图片验证码信息的参数的名称
     */
    public static final String DEFAULT_PARAMETER_NAME_CODE_IMAGE = "imageCode";
    /**
     * 验证短信验证码时，http请求中默认的携带短信验证码信息的参数的名称
     */
    public static final String DEFAULT_PARAMETER_NAME_CODE_SMS = "smsCode";
    /**
     * 发送短信验证码 或 验证短信验证码时，传递手机号的参数的名称
     */
    public static final String DEFAULT_PARAMETER_NAME_MOBILE = "mobile";
    
}
```

短信登录验证逻辑

```java
public class SmsCodeAuthenticationProvider implements AuthenticationProvider {

    private UserDetailsService userDetailsService;

    /**
     * 身份认证的逻辑
     * @param authentication
     * @return
     * @throws AuthenticationException
     */
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {

        SmsCodeAuthenticationToken authenticationToken = (SmsCodeAuthenticationToken) authentication;

        UserDetails user = userDetailsService.loadUserByUsername((String) authenticationToken.getPrincipal());

        if (user == null) {
            throw new InternalAuthenticationServiceException("无法获取用户信息");
        }
        /**
         *  1: 用户认证信息
         *  2：用户权限
         */
        SmsCodeAuthenticationToken authenticationResult = new SmsCodeAuthenticationToken(user, user.getAuthorities());
        //将之前未认证的请求放进认证后的Token中
        authenticationResult.setDetails(authenticationToken.getDetails());

        return authenticationResult;
    }

    /**
     * AuthenticationManager带着Token调用Provider
     * 判断传进来的Token最终调用的是哪个Provider
     * @param authentication
     * @return
     */
    @Override
    public boolean supports(Class<?> authentication) {
        return SmsCodeAuthenticationToken.class.isAssignableFrom(authentication);
    }

    public UserDetailsService getUserDetailsService() {
        return userDetailsService;
    }

    public void setUserDetailsService(UserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }
}
```

校验码类型

```java
public enum ValidateCodeType {

    /**
     * 短信验证码
     */
    SMS {
        public String getParamNameOnValidate() {
            return SecurityConstants.DEFAULT_PARAMETER_NAME_CODE_SMS;
        }
    },
    IMAGE {
        public String getParamNameOnValidate(){
            return SecurityConstants.DEFAULT_PARAMETER_NAME_CODE_IMAGE;
        }
    };


    /**
     * 校验时从请求中获取的参数的名字
     * @return
     */
    public abstract String getParamNameOnValidate();
}
```

依赖查找出相应的验证码处理器,校验码处理器管理器

```java
public class ValidateCodeProcessorHolder {

    //依赖查找
    @Autowired
    private Map<String, ValidateCodeProcessor> validateCodeProcessors;

    /**
     * @param type
     * @return
     */
    public ValidateCodeProcessor findValidateCodeProcessor(ValidateCodeType type) {
        return findValidateCodeProcessor(type.toString().toLowerCase());
    }

    private ValidateCodeProcessor findValidateCodeProcessor(String type) {
        String name = type.toLowerCase() + ValidateCodeProcessor.class.getSimpleName();
        ValidateCodeProcessor processor = validateCodeProcessors.get(name);
        if (processor == null) {
            throw new ValidateCodeException("验证码处理器" + name + "不存在");
        }
        return processor;
    }

}
```

校验码处理器，封装不同校验码的处理逻辑

```java
public interface ValidateCodeProcessor {

    /**
     * 验证码放入session时的前缀
     */
    String SESSION_KEY_PREFIX = "SESSION_KEY_FOR_CODE_";


    /**
     * 创建校验码
     *
     * @param request
     * @throws Exception
     */
    void create(ServletWebRequest request) throws Exception;

    /**
     * 校验验证码
     *
     * @param servletWebRequest
     * @throws Exception
     */
    void validate(ServletWebRequest servletWebRequest);
}
```

抽象的验证码处理器AbstractValidateCodeProcessor

```java
public abstract class AbstractValidateCodeProcessor<C extends ValidateCode> implements ValidateCodeProcessor {

    /**
     * 收集系统中所有的 {@link ValidateCodeGenerator} 接口的实现。
     */
    @Autowired
    private Map<String, ValidateCodeGenerator> validateCodeGenerators;

    /**
     * 操作session的工具类
     */
    private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();

    @Override
    public void create(ServletWebRequest request) throws Exception {
        C validateCode = generate(request);
        save(request, validateCode);
        send(request, validateCode);
    }

    /**
     * 生成校验码
     *
     * @param request
     * @return
     */
    @SuppressWarnings("unchecked")
    private C generate(ServletWebRequest request) {
        String type = getValidateCodeType(request).toString().toLowerCase();
        String generatorName = type + ValidateCodeGenerator.class.getSimpleName();
        ValidateCodeGenerator validateCodeGenerator = validateCodeGenerators.get(generatorName);
        if (validateCodeGenerator == null) {
            throw new ValidateCodeException("验证码生成器" + generatorName + "不存在");
        }
        return (C) validateCodeGenerator.generate(request);
    }

    /**
     * 保存校验码
     *
     * @param request
     * @param validateCode
     */
    private void save(ServletWebRequest request, C validateCode) {
        sessionStrategy.setAttribute(request, getSessionKey(request), validateCode);
    }

    /**
     * 构建验证码放入session时的key
     *
     * @param request
     * @return
     */
    private String getSessionKey(ServletWebRequest request) {
        return SESSION_KEY_PREFIX + getValidateCodeType(request).toString().toUpperCase();
    }

    /**
     * 发送校验码，由子类实现
     *
     * @param request
     * @param validateCode
     * @throws Exception
     */
    protected abstract void send(ServletWebRequest request, C validateCode) throws Exception;

    /**
     * 根据请求的url获取校验码的类型
     *
     * @param request
     * @return
     */
    private ValidateCodeType getValidateCodeType(ServletWebRequest request) {
        String type = StringUtils.substringBefore(getClass().getSimpleName(), "CodeProcessor");
        return ValidateCodeType.valueOf(type.toUpperCase());
    }

    @SuppressWarnings("unchecked")
    @Override
    public void validate(ServletWebRequest request) {

        ValidateCodeType processorType = getValidateCodeType(request);
        String sessionKey = getSessionKey(request);

        C codeInSession = (C) sessionStrategy.getAttribute(request, sessionKey);

        String codeInRequest;
        try {
            codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(),
                    processorType.getParamNameOnValidate());
        } catch (ServletRequestBindingException e) {
            throw new ValidateCodeException("获取验证码的值失败");
        }

        if (StringUtils.isBlank(codeInRequest)) {
            throw new ValidateCodeException(processorType + "验证码的值不能为空");
        }

        if (codeInSession == null) {
            throw new ValidateCodeException(processorType + "验证码不存在");
        }

        if (codeInSession.isExpried()) {
            sessionStrategy.removeAttribute(request, sessionKey);
            throw new ValidateCodeException(processorType + "验证码已过期");
        }

        if (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) {
            throw new ValidateCodeException(processorType + "验证码不匹配");
        }

        sessionStrategy.removeAttribute(request, sessionKey);
    }
}
```

校验验证码的过滤器ValidateCodeFilter

```java
@Data
@Slf4j
@Component("validateCodeFilter")
public class ValidateCodeFilter extends OncePerRequestFilter implements InitializingBean {

    /**
     * 验证码校验失败处理器
     */
    @Autowired
    private AuthenticationFailureHandler authenticationFailureHandler;

    /**
     * 系统配置信息
     */
    @Autowired
    private SecurityProperties securityProperties;

    /**
     * 系统中的校验码处理器
     */
    @Autowired
    private ValidateCodeProcessorHolder validateCodeProcessorHolder;

    /**
     * 存放所有需要校验验证码的url
     */
    private Map<String, ValidateCodeType> urlMap = new HashMap<>();

    /**
     * 验证请求url与配置的url是否匹配的工具类
     */
    private AntPathMatcher pathMatcher = new AntPathMatcher();

    /**
     * 初始化要拦截的url配置信息
     * @throws ServletException
     */
    @Override
    public void afterPropertiesSet() throws ServletException {
        super.afterPropertiesSet();

        urlMap.put(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_FORM, ValidateCodeType.IMAGE);
        addUrlToMap(securityProperties.getCode().getImage().getUrl(), ValidateCodeType.IMAGE);

        urlMap.put(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_MOBILE, ValidateCodeType.SMS);
        addUrlToMap(securityProperties.getCode().getSms().getUrl(), ValidateCodeType.SMS);

    }

    /**
     * 将系统中配置的需要校验验证码的URL根据校验的类型放入map
     *
     * @param urlString
     * @param type
     */
    protected void addUrlToMap(String urlString, ValidateCodeType type) {
        if (StringUtils.isNotBlank(urlString)) {
            String[] urls = StringUtils.splitByWholeSeparatorPreserveAllTokens(urlString, ",");
            for (String url : urls) {
                urlMap.put(url, type);
            }
        }
    }

    /**
     * @see
     * org.springframework.web.filter.OncePerRequestFilter#doFilterInternal(
     * javax.servlet.http.HttpServletRequest,
     * javax.servlet.http.HttpServletResponse, javax.servlet.FilterChain)
     * @param request
     * @param response
     * @param filterChain
     * @throws ServletException
     * @throws IOException
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        ValidateCodeType type = getValidateCodeType(request);
        if (type != null) {
            logger.info("校验请求(" + request.getRequestURI() + ")中的验证码,验证码类型" + type);
            try {
                validateCodeProcessorHolder.findValidateCodeProcessor(type).validate(new ServletWebRequest(request, response));
                logger.info("验证码校验通过");
            } catch (ValidateCodeException exception) {
                authenticationFailureHandler.onAuthenticationFailure(request, response, exception);
                return;
            }
        }

        filterChain.doFilter(request, response);
    }

    /**
     * 获取校验码的类型，如果当前请求不需要校验，则返回null
     *
     * @param request
     * @return
     */
    private ValidateCodeType getValidateCodeType(HttpServletRequest request) {
        ValidateCodeType result = null;
        if (!StringUtils.equalsIgnoreCase(request.getMethod(), "get")) {
            Set<String> urls = urlMap.keySet();
            for (String url : urls) {
                if (pathMatcher.match(url, request.getRequestURI())) {
                    result = urlMap.get(url);
                }
            }
        }
        return result;
    }

}
```

短信验证码和短信登录的相关类进行的配置类

```java
@Component
public class SmsCodeAuthenticationSecurityConfig extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {

    @Autowired
    private AuthenticationSuccessHandler imoocAuthenticationSuccessHandler;

    @Autowired
    private AuthenticationFailureHandler imoocAuthenticationFailureHandler;

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    public void configure(HttpSecurity http) throws Exception {

        SmsCodeAuthenticationFilter smsCodeAuthenticationFilter = new SmsCodeAuthenticationFilter();
        smsCodeAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class));
        smsCodeAuthenticationFilter.setAuthenticationSuccessHandler(imoocAuthenticationSuccessHandler);
        smsCodeAuthenticationFilter.setAuthenticationFailureHandler(imoocAuthenticationFailureHandler);

        SmsCodeAuthenticationProvider smsCodeAuthenticationProvider = new SmsCodeAuthenticationProvider();
        smsCodeAuthenticationProvider.setUserDetailsService(userDetailsService);

        http.authenticationProvider(smsCodeAuthenticationProvider)
                .addFilterAfter(smsCodeAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

    }

}
```

密码登录的一些配置

```java
public class AbstractChannelSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    protected AuthenticationSuccessHandler imoocAuthenticationSuccessHandler;

    @Autowired
    protected AuthenticationFailureHandler imoocAuthenticationFailureHandler;

    protected void applyPasswordAuthenticationConfig(HttpSecurity http) throws Exception {
        http.formLogin()
                .loginPage(SecurityConstants.DEFAULT_UNAUTHENTICATION_URL)
                .loginProcessingUrl(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_FORM)
                .successHandler(imoocAuthenticationSuccessHandler)
                .failureHandler(imoocAuthenticationFailureHandler);
    }

}
```

```java
@Component("validateCodeSecurityConfig")
public class ValidateCodeSecurityConfig extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {

    @Autowired
    private Filter validateCodeFilter;

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.addFilterBefore(validateCodeFilter, AbstractPreAuthenticatedProcessingFilter.class);
    }

}
```

测试：

![2019-03-25_203418](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-25_203418.png)

### OAuth协议简介

![2019-03-26_135354](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-26_135354.png)

![2019-03-26_135557](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-26_135557.png)

![2019-03-26_140018](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-26_140018.png)

### SpringSocial简介

![2019-03-26_140338](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-26_140338.png)

![2019-03-26_140533](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-26_140533.png)

![2019-03-26_141233](https://raw.githubusercontent.com/duanwandao/imooc-security/master/imooc-security/docs/pictures/2019-03-26_141233.png)

### 开发QQ登录（上）